<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>My Personal Blog with Math</title>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript">
    MathJax = {
        tex: {
            packages: {'[+]': ['ams', 'newcommand', 'color']}
        }
    };
</script>
        <script type="text/javascript">
        MathJax = {
            tex: {
                macros: {
                    box: ['\\mathord{\\Box}', 0],
                    diamond: ['\\mathord{\\Diamond}', 0]
                }
            }
        };
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
    </style>
    </head>
    <body>
        <header>
        <h1>Monoidal Categories: Part 2</h1>
        <p>First published on: 2024-06-01</p>
    </header>
    <main>
        <article>
            <p>
              Hi, everyone. I go to visit another city, and then I will go home and stay for about a week, then come back to school. This time we are going to discuss coherence result of monoidal categories. To review part 1 of monoidal categories, click <a href="post1.html">here</a>.
            </p>

            <p>
                It took me nearly five days to make things clear. I mean mainly I thought about this only when I was walking or riding a bike. But anyway, I finally worked it out, and I understand that it is essentially a commuting result, which is actually very intuitive. However, the proof requires some techniques, and even it is tricky to state 
                the main result cleverly. Therefore, I believe that we have to do the tasks step by step.
            </p>

            <p>
                Firstly, we define a monoidal category \(W\), which can be seen as a prototype of all monoidal categories. Consider a symbol \(e_0\), which stands for unit. Consider another symbol\((-)\), which stands for a blank to be written. Then the objects of this category are built recursively in the following way. \(e_0\) and \((-)\) are 
                two basic ones, and if \(v\) and \(w\) are two objects of \(W\), then \((v\box w)\) is also an object of \(W\), and all objects are constructed in this way. Note that it is quite like the way of defining formulas in any logic. After defining the objects, we define the morphisms, but wait, we have to introduce the concept of length. 
                Let \(v\) be an object of \(W\), then the length of \(v\) is the number of \((-)\) in \(v\). This can also be defined recursively: \(length(e_0)=0\), \(length((-))=1\) and \(length(v\box w)=length(v)+length(w)\). Then we define morphism between objects with the same length, and for any two objects with the same length, say \(v\) 
                and \(w\) with \(length(v)=length(w)\), there is a unique morphism from \(v\) to \(w\), i.e. \(|Hom(v,w)|=1\). Composition of morphisms is obvious. Actually, this category \(W\) can be seen as a pre-order.
            </p>

            <p>
                After defining the category \(W\), the Book introduces its first big result, which states that for any monoidal category \(B\), and arbitrary object \(b\) of \(B\), there exists a unique morphism of monoidal categories(which is a functor from that respects every relevent gredients) from \(W\) to \(B\) such that \((-)\) is mapped to
                \(b\). It is quite a intuitive result, and I don't want to prove it. Instead, this post is going to focus on another result, which I believe crucial. Roughly speaking, the results says that every diagram in a monoidal category that intuitively commutes must commute. What does it mean to be 'intuitively commutes'? Well, we can make 
                it precise. Consider an object in the category \(W\). We treat it as a word, and those \((-)\) in the object can be seen as blanks to be filled in, we we use objects in \(B\) to fill in the blanks. After all the blanks are filled with objects in \(B\), it forms another object of \(B\), in the most straightforward sense. But wait, maybe 
                we have to put some restrictions: we only fill in objects that are not \(e\) in \(B\). This is simply because we already have \(e_0\). So now we can put things together. Let \(v\) be an object of \(W\) and its length is \(n\), which is greater or equal to \(0\). Now, assume \(\vec{a}\) is a n-ary assignments of non-\(e\) elements in \(B\), 
                then let \(v_{\vec{a}}\) be the object in \(B\) constructed by filling objects in \(\vec{a}\) into \(v\)(respects their order in \(\vec{a}\)) and replace \(e_0\) by \(e\). This solves the object defining issue.
            </p>

            <p>
                Then if \(v\) and \(w\) are two objects in \(W\), and they have the same length: \(length(v)=length(w)=n\geq 0\), then we can apply morphism constructed by \(\alpha\), \(\lambda\) and \(\rho\) to go from one to another. Formally, we define what are constructable morphism of \(B\). The constructable morphism of \(B\) can only be constructed 
                in the following way: \(1\), \(\alpha\), \(\alpha^{-1}\), \(\lambda\), \(\lambda^{-1}\), \(\rho\) and \(\rho^{1}\) are constructable morphisms, and if \(\beta\) and \(\beta'\) are constructable morphisms, then so does \(\beta\box \beta'\). Here we do not specify the indecies of those morphism, but I believe things are clear. And now we are 
                able to state our main result:
            </p>
                
            <p>
                - Assume \(v\) and \(w\) are two objects in \(W\), and they have the same length: \(length(v)=length(w)=n\geq 0\). Then for every \(\vec{a}\), which is a n-ary vector of non-\(e\) elements in a monoidal category, any two constructable morphisms from \(v_{\vec{a}}\) to \(w_{\vec{a}}\) are the same. So essentially, this result states that 
                this is a unique constructable morphism from \(v_{\vec{a}}\) to \(w_{\vec{a}}\).
            </p>

            <p>
                If we think a little bit, we will find that this result is actually very intuitive. But to prove it, we have to do some work, which I think is very helpful in understanding the monoidal categories. So let us do it step by step.      
            </p>
            
            <p>
                It is quite helpful to observe that contructable morphisms can be decomposed into some more basic morphism. We define basic morphisms recursively as the following: \(1\), \(\alpha\), \(\alpha^{-1}\), \(\lambda\), \(\lambda^{-1}\), \(\rho\) and \(\rho^{1}\) are basic morphisms, and if \(\beta\) is a basic morphism, then so does \(1\box\beta\) and \(\beta\box 1\). 
                Then we understand that every basic morphism is either the identical morphism, or contains exactly one of the \(\alpha\), \(\alpha^{-1}\), \(\lambda\), \(\lambda^{-1}\), \(\rho\) and \(\rho^{1}\), and it occurs only once. Now, I claim that every constructable morphism is a composition of some basic morphisms. Why? This can be proved by induction on the 
                complexity of constructable morphism. Clearly all the basic entity of constructable morphism are themselves basic morphisms; also, consider a constructable morphism of the form \(\beta\box \beta'\), then we understand that \(\beta\box\beta'=(\beta\box 1)(1\box \beta')\), and both \(\beta\box 1\) and \(1\box\beta'\) can be decomposed into basic morphisms by 
                induction hypothesis, thus so does \(\beta\box\beta'\).
            </p>

            <p>
                Now, for two objects \(v\) and \(w\) having the same length, and if \(\beta\) is a constructable morphism, we know it is a composition of some basic morphisms. But it is better to work only with those basic morphism constructed by \(1\), \(\alpha\), \(\lambda\) and \(\rho\), because those constructed by 
                \(\alpha^{-1}\), \(\lambda^{-1}\) and \(\rho^{-1}\) are simply their inverses. And surprisingly, to prove the result, it suffices to prove it in a special case. We understand that for any \(\vec{a}\), there is a classical way to compose it: we require all left parentheses occur on the left-most. For example, given \(\vec{a}=(a_1,a_2,a_3)\), the the classical way 
                of composing it is \(((a_1\box a_2)\box a_3)\). For \(\vev{a}\), we use \(m_{\vec{a}}\) to denote its classical composition. Then I claim it suffices to show that for any \(v\) and \(\vec{a}\), there is a unique way to go from \(v_{\vec{a}}\) to \(m_{\vec{a}}\) by composing basic morphisms that constructed from \(1\), \(\alpha\), \(\lambda\) and \(\rho\). Once 
                we proved this, it is straightforward to show that the unique constructable morphism from \(v_{\vec{a}}\) to \(w_{\vec{a}}\) is \(v_{\vec{a}}\rightarrow m_{\vec{a}}\rightarrow w_{\vec{a}}\), where the two arrows are unique.
            </p>

            <p>
                So in the rest of the post, we are going to focus on the proof of that specific result. Actually it is not hard, simply discussion by cases.
            </p>

            
                
        </article>
        <p><a href="index.html">Back to Home</a></p>
    </main>
        <!-- Your content goes here -->
    </body>
</html>
