<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>My Personal Blog with Math</title>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript">
    MathJax = {
        tex: {
            packages: {'[+]': ['ams', 'newcommand', 'color']}
        }
    };
</script>
        <script type="text/javascript">
        MathJax = {
            tex: {
                macros: {
                    box: ['\\mathord{\\Box}', 0],
                    diamond: ['\\mathord{\\Diamond}', 0]
                }
            }
        };
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
    </style>
    </head>
    <body>
        <header>
        <h1>Monoidal Categories: Part 2</h1>
        <p>First published on: 2024-06-01</p>
    </header>
    <main>
        <article>
            <p>
              Hi, everyone. I go to visit another city, and then I will go home and stay for about a week, then come back to school. This time we are going to discuss coherence result of monoidal categories. To review part 1 of monoidal categories, click <a href="post1.html">here</a>.
            </p>

            <p>
                It took me nearly five days to make things clear. I mean mainly I thought about this only when I was walking or riding a bike. But anyway, I finally worked it out, and I understand that it is essentially a commuting result, which is actually very intuitive. However, the proof requires some techniques, and even it is tricky to state 
                the main result cleverly. Therefore, I believe that we have to do the tasks step by step.
            </p>

            <p>
                Firstly, we define a monoidal category \(W\), which can be seen as a prototype of all monoidal categories. Consider a symbol \(e_0\), which stands for unit. Consider another symbol\((-)\), which stands for a one bit to be written. Then the objects of this category are built recursively in the following way. \(e_0\) and \((-)\) are 
                two basic ones, and if \(v\) and \(w\) are two objects of \(W\), then \((v\box w)\) is also an object of \(W\), and all objects are constructed in this way. Note that it is quite like the way of defining formulas in any logic. After defining the objects, we define the morphisms, but wait, we have to introduce the concept of length. 
                Let \(v\) be an object of \(W\), then the length of \(v\) is the number of \((-)\) in \(v\). This can also be defined recursively: \(length(e_0)=0\), \(length((-))=1\) and \(length(v\box w)=length(v)+\length(w)\).
            </p>

            
        </article>
        <p><a href="index.html">Back to Home</a></p>
    </main>
        <!-- Your content goes here -->
    </body>
</html>
